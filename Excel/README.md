# Office Wiki for Excel 1.0

## 目录

[Excel函数](#h2-1)

- [函数语法](#h3-1-1)

- [运算符](#h3-1-2)

- [相对引用与绝对引用](#h3-1-3)

[函数表](#h2-2)

- [常用函数](#h3-2-1)

   - [求和](#h4-2-1-1)
   
   - [求个数](#h4-2-1-2)
   
   - [求平均数](#h4-2-1-3)
   
   - [求积](#h4-2-1-4)
   
   - [四舍五入](#h4-2-1-5)
   
   - [排位](#h4-2-1-6)
   
   - [取绝对值](#h4-2-1-7)
   
   - [取整](#h4-2-1-8)
   
- [逻辑函数](#h3-2-2)

   - [条件函数](#h4-2-2-1)
   
   - [条件求和](#h4-2-2-2)
   
   - [条件求个数](#h4-2-2-3)
   
- [文本函数](#h3-2-3)

   - [截取](#h4-2-3-1)
   
   - [取文本长度](#h4-2-3-2)
  
   - [合并字符](#h4-2-3-3)
  
   - [查找](#h4-2-3-4)
   
- [进阶](#h3-2-4)

   - [条件查找](#h4-2-4-1)
   
   - [超链接](#h4-2-4-2)

## Changelog

本Wiki百科将介绍常用Excel函数用法及常用的函数表。

## Excel函数 <a id="h2-1"></a>

#### 函数语法 <a id="h3-1-1"></a>

```
FUNC(arg1, arg2, ...)
```

``FUNC``为函数名，括号内的``arg1``、``arg2``等均为要传入的参数。

> 如何理解函数与参数？
>
> 我们都知道在数学中，类似于``f(x)``形式的被称为函数。函数的作用即是根据传入的x得到最后f的值。那么类似地，在Excel中，我们可以将函数理解为多元函数，即根据传入的多个参数的值，计算出最终的函数值。

#### 运算符 <a id="h3-1-2"></a>

Excel支持以下**公式运算符**：

``+``（加）、``-``（减）、``*``（乘）、``/``（除）、``%``（百分号）、``^``（乘幂）。

Excel还支持以下**比较运算符**：

``>``（大于）、``<``（小于）、``=``（等于）、``<=``（小于等于）、``>=``（大于等于）、``<>``（不等于）。

除此之外，参数之间的连接可以使用下列**引用运算符**：

``:``（区域运算符）、``,``（联合运算符）。

> 如何理解引用运算符？
>
> 假设有一个函数``FUNC(A1:A5)``，它的意思是将``A1``-``A5``这个单元格区域的所有值作为参数传给函数``FUNC``。它等同于``FUNC(A1,A2,A3,A4,A5)``。当需要传递某大块区域的单元格作为参数时，使用区域运算符更为简便。

#### 相对引用与绝对引用 <a id="h3-1-3"></a>

当单元格位置前不加``$``时，则代表其为**相对引用**。在行或列前加``$``时则表示为**绝对引用**。

```
A1		相对引用
$A1		绝对引用，锁定第A列
A$1		绝对引用，锁定第1行
$A$1	绝对引用，锁定到单元格A1
```

> 什么是相对引用和绝对引用？
>
> 假设我们使用函数``FUNC(A1)``计算时，如果我们移动了单元格``A1``的位置到``B2``，那么``FUNC(A1)``会自动变更成``FUNC(B2)``，意思就是，当使用相对引用时，参数引用会跟随单元格的位置变化而变化。如果我们在列前加上``$``使其变成``FUNC($A1)``，意思就是，无论我们怎么移动单元格的列位置，``FUNC($A1)``都不会变，但移动其行位置会改变；行前加``$``同理。当我们在行列前都加上``$``，即``FUNC($A$1)``，说明无论怎么改变A1的位置，该函数的参数将永远不会改变。

## 函数表 <a id="h2-2"></a>

该函数表中，``[arg]``表示参数``arg``可以省略。

### 常用函数 <a id="h3-2-1"></a>

#### 求和 <a id="h4-2-1-1"></a>

```
SUM(number1, [number2], ...)
```

计算出传入参数的所有单元格的所有值的和。

> 使用样例：计算单元格区域A1:A5所有值的和。
>
> ``SUM(A1:A5)``或``SUM(A1,A2,A3,A4,A5)``

#### 求个数 <a id="h4-2-1-2"></a>

```
COUNT(value1, [value2], ...)
```

求传入的单元格的个数。通常用于传入单元格区域。

#### 求平均数 <a id="h4-2-1-3"></a>

```
AVERAGE(number1, [number2], ...)
```

求传入的所有单元格（或单元格区域）中的数值的平均数。

#### 求积 <a id="h4-2-1-4"></a>

```
PRODUCT(number1, [number2], ...)
```

求传入的所有单元格（或单元格区域）中的数值的乘积。

#### 四舍五入 <a id="h4-2-1-5"></a>

```
ROUND(number, num_digits)
```

``number``为要处理的数值所在的单元格，``num_digits``为需要保留的小数位数。

#### 排位 <a id="h4-2-1-6"></a>

```
RANK(number, ref, [order])
```

``number``为要计算出排位位置的单元格位置，``ref``为排名范围的单元格区域，``order``为序别（``1``为升序，``0``为降序）。返回``number``在``ref``中的排名值。

> 使用样例：求单元格A1在A1:A10中的升序排序名次。
>
> ``RANK(A1,A1:A10,1)``

#### 取绝对值 <a id="h4-2-1-7"></a>

```
ABS(number)
```

#### 取整 <a id="h4-2-1-8"></a>

```
INT(number)
```

### 逻辑函数 <a id="h3-2-2"></a>

#### 条件函数 <a id="h4-2-2-1"></a>

```
IF(logical_test, value_if_true, value_if_false)
```

判断是否满足``logical_test``，如果满足则返回``value_if_true``，如果不满足则返回``value_if_false``。

> 使用样例：判断A1和A2单元格数值的大小，大于显示OK，小于显示NO。
>
> ``IF(A1>A2,"OK","NO")``

> 该函数最多支持7层嵌套。

> 注意：如果需要返回文字，文字必须要用引号括起来。

#### 条件求和 <a id="h4-2-2-2"></a>

```
SUMIF(range, criteria, [sum_range])
```

如果没有传入``sum_range``，则对在单元格区域``range``中满足条件``criteria``的单元格进行求和；如果传入``sum_range``，则对满足条件的``range``单元格对应的``sum_range``单元格进行求和。

> 使用样例1：计算单元格区域A1:A5所有大于等于2的值的和。
>
> ``SUMIF(A1:A5,">=2")``
>
> 使用样例2：对单元格区域A1:A4中小于300的数值对应的C1:C4单元格中的数值求和。
>
> ``SUMIF(A1:A4,"<300",C1:C4)``

#### 条件求个数 <a id="h4-2-2-3"></a>

```
COUNTIF(range, criteria)
```

求单元格区域``range``的满足条件``criteria``的单元格个数。

> 使用样例：求单元格区域A1:A10中数值大于90的个数。
>
> ``COUNTIF(A1:A10,">90")``

### 文本函数 <a id="h3-2-3"></a>

本节中变量``text``或其他文本变量既可以传入含有文本的单元格，也可以传入一个具体文本。文本必须使用英文引号括起来。具体可参考[合并字符]()中的样例。

#### 截取 <a id="h4-2-3-1"></a>

```
LEFT(text, [num_chars])
```

截取``text``的前``num_chars``个字符。如果省略``num_chars``，则截取第一个字符。

```
RIGHT(text, [num_chars])
```

截取``text``的后``num_chars``个字符。如果省略``num_chars``，则截取最后一个字符。

```
MID(text, start_num, num_chars)
```

截取``text``的中间数个字符。从第``start_num``个开始截取，截取长度为``num_chars``。

#### 取文本长度 <a id="h4-2-3-2"></a>

```
LEN(text)
```

获取``text``里的字符个数。

#### 合并字符 <a id="h4-2-3-3"></a>

```
CONCATENATE(text1, [text2], ...)
```

合并传入的所有单元格（或单元格区域）中的文本。

> 使用样例：单元格A1中有文本“Hello”，单元格A2中有文本“World”。将A1和A2中的文本合并成“HelloWorld”。
>
> ``CONCATENATE(A1,A2)``或``CONCATENATE(A1:A2)``
>
> 也可以使用``CONCATENATE("Hello","World")``

#### 查找 <a id="h4-2-3-4"></a>

```
FIND(find_text, within_text, [start_num])
```

查找第一个``find_text``在``within_text``中的位置。``start_num``表示起始查找位置，如果被忽略，则从头查找。

> 使用样例
>
> ``FIND("a","abcdabcd")``返回``1``；``FIND("a","abcdabcd",3)``返回``5``。

### 进阶 <a id="h3-2-4"></a>

#### 条件查找 <a id="h4-2-4-1"></a>

```
VLOOKUP(lookup_value, table_array, col_index_num, range_lookup)
```

在单元格区域``table_array``中搜索第一个元素``lookup_value``，确定单元格在区域中的行序号，然后通过指定的列序号``col_index_num``定位到精确单元格并返回其值。如果要查找大致匹配，``range_lookup``传入``TRUE``，如果要精确查找，传入``FALSE``。

#### 超链接 <a id="h4-2-1-2"></a>

```
HYPERLINK(link_location, friendly_name)
```

创建一个快捷方式链接，通过点击可以打开一个存储在本地或网络上的文档。要打开的文件的路径为``link_location``。``friendly_name``为要显示在单元格里的文本，如果忽略，则单元格中显示``link_location``的文本。
